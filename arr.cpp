//Υλοποίηση 1) αταξινόμητος πίνακας
#include "arr.h"
#include <iostream>
using namespace std;

void arr::insert(string s) //εισαγωγή νέας λέξης
{
	if (c==size) //οι αυξήσεις που θα κάνουμε στον πίνακα θα είναι +100 θέσεις
	{
		word *temp= new word[size+100]; //ορίζουμε μεγαλύτερο πίνακα
		for (int i=0; i<size; i++)
		{	
			temp[i].w=b[i].w;
			temp[i].t=b[i].t;
		}
		//memcpy(temp,b,size*sizeof(word)); //αντιγράφουμε τα δεδομένα

		delete [] b; //απελευθερώνουμε τον χώρο που έπιανε ο προηγούμενος πίνακας

		b = temp; //αντιγράφουμε την διεύθυνση του νέου πίνακα στον δείκτη μας
		size+=100; //αυξάνουμε το μέγεθος της size
	}
	b[c].w=s; //αντιγράφουμε συμβολοσειρά
	b[c].t=1; //αυξάνουμε επαναλήψεις
	//cout<<c<<endl;
	c++; //αυξάνουμε μετρητή

}

int arr::find(string s) //αναζήτηση, δέχεται μία συμβολοσειρά για όρισμα
{
	for (int i=0; i<size; i++) //περνάει γραμμικά
	{
		if (b[i].w.compare(s)==0) //αν την βρει σε κάποιο κελί του πίνακα,
		{													
			b[i].t++;	//αυξάνει τις επαναλήψεις της λέξης
			return i; //επιστρέφει την θέση που το βρήκε, χωρίς ιδιαίτερο λόγο
		}
	}
	return -1; //διαφορετικά επιστρέφει τιμή φρουρό
}

void arr::del(string s) //διαγραφή καταχώρησης υπάρχουσας λέξης
{
	int k= find(s); //αναζήτηση για να βρούμε σε ποια θέση είναι η λέξη

	for (int i=k; i<c-1; i++) //ξεκινάμε το i από αυτήν την θέση
	{
		b[i].w=b[i+1].w; //αντιγράφουμε μία προς μία τις λέξεις στην προηγούμενη θέση στον πίνακα, ουσιαστικα δεν "διαγράφουμε", αλλά κάνουμε overwrite
		b[i].t=b[i+1].t;
	}
	b[c].w="";
	b[c].t=0;
}